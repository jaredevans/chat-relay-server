<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebSocket + WebRTC Video Chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: monospace; background: #181c24; color: #f2f2f2; margin: 0; }
    #chat { width: 100%; height: 40vh; background: #23283b; overflow-y: auto; padding: 1em; border-bottom: 1px solid #333;}
    #inputBar { display: flex; }
    #userInput { flex: 1; padding: 1em; background: #111; color: #f2f2f2; border: none;}
    #sendBtn, #videoBtn, #hangupBtn { padding: 1em; background: #5d67ee; color: #fff; border: none; cursor: pointer; margin-left: 0.5em;}
    #sendBtn:hover, #videoBtn:hover, #hangupBtn:hover { background: #6e78ff; }
    #info { padding: .5em 1em; color: #82b1ff; font-size: 0.95em;}
    .me { color: #9fc6ff; }
    #videos { display: flex; gap: 1em; align-items: center; padding: 1em; background: #222; }
    video { width: 180px; height: 135px; background: #111; border: 2px solid #444; border-radius: 6px; }
    @media (max-width: 600px) {
      #videos { flex-direction: column; }
      video { width: 96vw; height: 54vw; }
    }
  </style>
</head>
<body>
  <div id="chat" aria-live="polite"></div>
  <div id="info"></div>
  <div id="inputBar">
    <input id="userInput" type="text" placeholder="Type your message or commands here..." autocomplete="off" />
    <button id="sendBtn">Send</button>
    <button id="videoBtn">Start Video Chat</button>
    <button id="hangupBtn">Hang Up</button>
  </div>
  <div id="videos">
    <div>
      <div style="font-size:.9em;text-align:center">You</div>
      <video id="localVideo" autoplay muted playsinline></video>
    </div>
    <div>
      <div style="font-size:.9em;text-align:center">Peer</div>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </div>
  <script>
    let ws;
    let quitting = false;
    let myCode = "";
    let myName = "";

    let localStream = null;
    let peerConnection = null;
    let videoChatRequested = false;
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }; // Google's STUN

    function log(msg, cls="") {
      const c = document.getElementById('chat');
      let el = document.createElement('div');
      if (cls) el.className = cls;
      el.textContent = msg;
      c.appendChild(el);
      c.scrollTop = c.scrollHeight;                                                                                         }
    function updateInfo() {
      document.getElementById('info').textContent =
        `Your chat code is ${myCode}, your name is "${myName}"`;
    }
    function info(msg) {
      document.getElementById('info').textContent = msg;
    }

    function connect() {
      ws = new WebSocket("wss://chat.jarednevans.com/ws/");
      ws.onopen = () => { info("Connected. Waiting for server..."); };
      ws.onmessage = (evt) => {                                                                                                 const msg = evt.data;
        if (msg.startsWith("CONNECTED:")) {
          let parts = msg.split(":");
          myCode = parts[1];
          myName = parts[2];
          updateInfo();
          log("Welcome! Use /join CODE, /name NEWNAME, /chatroom, /list, /quit");
        }
        else if (msg.startsWith("PAIR:")) {
          let [,code,name] = msg.split(":",3);
          log(`[Connected! You are chatting with ${name} (code ${code})]`, "sys");
          resetVideoState();
          videoChatRequested = false; // Reset on new pair
        }
        else if (msg.startsWith("MSGFROM:")) {
          let [,sender,text] = msg.split(":",3);
          log(`${sender}: ${text}`, "peer");
        }
        else if (msg.startsWith("RENAMED:")) {
          let newName = msg.split(":",2)[1];
          log(`[Your chat partner is now: ${newName}]`, "sys");
        }
        else if (msg === "PEER_LEFT") {
          log("[Your chat partner disconnected. Type /join CODE to connect to another.]", "sys");
          resetVideoState();                                                                                                      videoChatRequested = false;
        }
        else if (msg === "PEER_LEFT_CHATROOM") {
          log("[Your chat partner has left for the chatroom.]", "sys");
          resetVideoState();
          videoChatRequested = false;
        }
        else if (msg.startsWith("CHATROOM:")) {
          let [,sender,text] = msg.split(":",3);
          log(`[${sender} @ chatroom]: ${text}`,"room");
        }
        else if (msg.startsWith("INFO:")) {
          log("[Info] " + msg.slice(5), "info");                                                                                }
        else if (msg.startsWith("ERROR:")) {
          log("[ERROR] " + msg.slice(6),"err");
        }
        // --- Video Chat Autostart Logic ---
        else if (msg === "VIDEO_PLEASE_START") {
          if (!videoChatRequested) {
            log("[Peer requested video chat. Starting video...]", "info");
            videoChatRequested = true;
            startVideoChat(true); // Don't trigger a new VIDEO_PLEASE_START
          }
        }
        // -- WebRTC signaling --
        else if (msg.startsWith("VIDEO_OFFER:")) {
          handleVideoOffer(JSON.parse(msg.slice("VIDEO_OFFER:".length)));
        }
        else if (msg.startsWith("VIDEO_ANSWER:")) {
          handleVideoAnswer(JSON.parse(msg.slice("VIDEO_ANSWER:".length)));
        }
        else if (msg.startsWith("VIDEO_ICE:")) {
          handleVideoICE(JSON.parse(msg.slice("VIDEO_ICE:".length)));
        }
        // --- Hang Up Logic ---
        else if (msg === "VIDEO_HANGUP") {
          log("[Peer hung up the video call.]", "info");
          resetVideoState();
        }
        else {
          log("[Server] " + msg, "sys");
        }
      };
      ws.onclose = () => {
        info("Connection closed.");
        log("[Disconnected from server.]");
        resetVideoState();
        videoChatRequested = false;
      };
      ws.onerror = (e) => {
        info("WebSocket error!");
        log("[WebSocket error: check console for details.]", "err");
        resetVideoState();
        videoChatRequested = false;
      };
    }

    connect();

    document.getElementById('sendBtn').onclick = send;
    document.getElementById('videoBtn').onclick = () => startVideoChat(false);
    document.getElementById('hangupBtn').onclick = hangUpVideoChat;
    document.getElementById('userInput').onkeydown = (e) => { if (e.key === "Enter") send(); };

    function send() {
      const inp = document.getElementById('userInput');
      let txt = inp.value.trim();
      if (!txt) return;
      if (!ws || ws.readyState !== 1) {
        log("[Cannot send: not connected.]","err");
        return;
      }
      if (txt === "/quit") {
        quitting = true;
        ws.send("LEAVE");
        info("Leaving chat...");
        ws.close();
      } else if (txt.startsWith("/join ")) {
        ws.send("JOIN:" + txt.split(" ",2)[1]);
      } else if (txt.startsWith("/name ")) {
        myName = txt.slice(6).trim();
        updateInfo();
        log(`[You are now known as: ${myName}]`, "sys");
        ws.send("RENAME:" + myName);
      } else if (txt === "/chatroom") {
        ws.send("/chatroom");
      } else if (txt === "/list") {
        ws.send("/list");
      } else {
        ws.send("MSG:" + txt);
        log(`You: ${txt}`, "me");
      }
      inp.value = "";
    }

    // ---- WebRTC Video Chat ----
    function startVideoChat(isFromPeer) {
      // Always clean up any old state before starting a new call
      resetVideoState();

      if (!ws || ws.readyState !== 1) {
        log("[Cannot start video: not connected.]", "err");
        return;
      }
      if (!videoChatRequested && !isFromPeer) {
        ws.send("VIDEO_PLEASE_START");
        videoChatRequested = true;
      }
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          localStream = stream;
          document.getElementById('localVideo').srcObject = stream;
          if (!isFromPeer) {
            setupPeerConnection(true); // Initiator creates connection and offer
          }
          // Answerer will set up connection on VIDEO_OFFER
        }).catch(err => {
          log("[Error accessing camera/microphone: " + err + "]", "err");
        });
    }

    function setupPeerConnection(isInitiator) {
      peerConnection = new RTCPeerConnection(config);

      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });
      }

      peerConnection.ontrack = e => {
        log("[Received remote video stream]", "info");
        document.getElementById('remoteVideo').srcObject = e.streams[0];
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          ws.send('VIDEO_ICE:' + JSON.stringify(e.candidate));
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log(`[ICE connection state: ${peerConnection.iceConnectionState}]`, "info");
      };

      if (isInitiator) {
        peerConnection.createOffer().then(offer => {
          peerConnection.setLocalDescription(offer);
          ws.send('VIDEO_OFFER:' + JSON.stringify(offer));
          log("[Sent video offer]", "info");
        });
      }
    }

    function handleVideoOffer(offer) {
      log("[Received video offer]", "info");
      // Always fully clean up before starting a new inbound call
      resetVideoState();
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          localStream = stream;
          document.getElementById('localVideo').srcObject = stream;
          setupPeerConnection(false);
          doHandleVideoOffer(offer);
        }).catch(err => {
          log("[Error accessing camera/mic for answer: " + err + "]", "err");
        });                                                                                                                 }
    function doHandleVideoOffer(offer) {
      peerConnection.setRemoteDescription(new RTCSessionDescription(offer)).then(() => {
        return peerConnection.createAnswer();
      }).then(answer => {
        peerConnection.setLocalDescription(answer);
        ws.send('VIDEO_ANSWER:' + JSON.stringify(answer));
        log("[Sent video answer]", "info");
      });
    }

    function handleVideoAnswer(answer) {
      log("[Received video answer]", "info");
      if (peerConnection) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    }

    function handleVideoICE(candidate) {
      log("[Received ICE candidate]", "info");
      if (peerConnection) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
      }
    }

    function hangUpVideoChat() {
      if (peerConnection) {
        ws.send("VIDEO_HANGUP");
        log("[You hung up the call.]", "info");
        resetVideoState();
      }
    }

    function resetVideoState() {
      // Clean up video and audio tracks
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        document.getElementById('localVideo').srcObject = null;
        localStream = null;
      }
      // Clean up connection and remote video
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        document.getElementById('remoteVideo').srcObject = null;
      }
    }

    window.onbeforeunload = () => {
      if (ws && ws.readyState === 1) ws.close();
      resetVideoState();
    };
  </script>
</body>
</html>
